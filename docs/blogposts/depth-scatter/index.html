
<!DOCTYPE html>
<html>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta charset="utf-8">
    <title>Owen Hindley | Depth Scatter Rendering in TouchDesigner</title>
    <meta name="description"
	content="Owen Hindley is a digital artist creating experiences for VR, theatre, installations, games, performance and the web using software, electronics and sound.">
    <meta name="author" content="Owen Hindley">
    <meta property="og:url" content="http://www.owenhindley.co.uk">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Owen Hindley">
    <meta property="og:image" content="http://www.owenhindley.co.uk/images/sharing-image.jpg">
    <meta property="og:description"
	content="Owen Hindley is a digital artist creating experiences for VR, theatre, installations, games, performance and the web using software, electronics and sound.">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Owen Hindley Portfolio">
    <meta name="twitter:description"
	content="Owen Hindley is a digital artist creating experiences for VR, theatre, installations, games, performance and the web using software, electronics and sound.">

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="icon" type="image/png" href="images/favicon.png">

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://use.typekit.net/bio5jjx.css">

    <link rel="stylesheet" href="../../css/normalize.css">
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/blogpost.css">
</head>
<body class="blogpost">
    <div class="container">

        <header>

            
            <h1>Owen Hindley</h1>

        </header>

        <nav>
            <label onclick="document.location.href = 'http://owenhindley.co.uk'">
                <input type="radio" name="nav"></input>
                <span>Back</span>
            </label>
        </nav>
        <main>
            <h1>Depth Scatter Rendering in TouchDesigner</h1>
            <h4>A technique for creating point clouds from simple 3D scenes</h4>
            
<section>

    <p>Here I'm going to show a rendering technique in TouchDesigner that I've
used frequently, both for live VJ performing and to make music videos like this one :</p>

    <div class="video-wrapper">
        <iframe src="https://www.youtube.com/embed/w5QxJTnQ20U" width="610" height="400" title="YouTube video player"
frameborder="0"
allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
allowfullscreen></iframe>
    </div>

    <p>I've been drawn to it because even with a relatively simple set of input 3D geometry, you
get an illusion of fine detail, it's quite easy to art direct, and super
fast, which is great when you already have some complex stuff going on with the
initial source geometry.</p>

    <p>Essentially it's a GPU particle system driven by the depth output of a much
simpler render within TouchDesigner - so let's see how it's done!</p>

</section>

<section>

    <h3>Step 1 - create a basic 3D scene.</h3>

    <p>This will be the scene that drives the particle system, so any large dynamic changes
to the world should happen here. </p>

    <p><img src="../../images/blog/depth-scatter/image4.png"></p>

    <p>Here I'm creating three primitives, arranging them using Transform SOPs, adding
point colours to each via the Point SOP, and merging them all together.</p>

    <p>We're going to be manipulating our particles a lot based on this scene's
depth, so things like tunnels, caves or objects spread between the foreground and background should work
well to demonstrate the technique.</p>
</section>
<section>

    <h3>Step 2 - setup basic scene renderer</h3>

    <p>
        <img src="../../images/blog/depth-scatter/image21.png"></p>
    <p>
            Now we take this merged geometry and pipe it into a Geometry
COMP, here called srcGeo.</p>

    <p>(Hint - huge time-saving tip that I saw somewhere, if you're dragging an output
from a SOP, keep the mouse button down, and then create a Geometry from the Tab menu, it'll wire up
the SOP geometry inside the COMP automatically, neat!)</p>

    <p>Then we set up Camera &amp; Light COMPs, create a simple Phong MAT, and finally a
Render TOP to output an image of our little scene. </p>

    <p>What's good to focus on here is good contrast in the lighting and range of
depth in the camera - we don't need to worry too much about texturing or aspects of the MAT at this
point, but we can tweak it later once the particle system is setup.</p>
</section>

<section>

    <h3>Step 3 - extract depth from render</h3>

    <p>Next we're going to add a Depth TOP and point it at our Render TOP (by adding
the path to the Render TOP in the OP field).</p>

    <p>
        <img src="../../images/blog/depth-scatter/image14.png"></p>

    <p>If you, like me, haven't previously looked at the Depth TOP, it's a
useful procedure to extract the depth map from your renders, which you can later use for post-effects like
depth of field (using a Lookup &amp; a Luma Blur TOP), or in this case, to drive a secondary particle
system.</p>
    <p>Now you may not be able to see much in the Depth TOP itself, in the image above you
can faintly see the outlines of our objects, but there's a nice feature in TOPs that let us visualise
the depth map more easily.</p>

    <p>Click on the Depth TOP, activate the viewer (star in the bottom-right, or press
'a'), right-click on the background and select 'Normalised Split'. You should then
see something like this :</p>
    <p>
        <img src="../../images/blog/depth-scatter/image17.png"></p>
    <p>You can also right-click and choose 'Display Pixel Values', which will
overlay the current pixel value underneath the mouse:</p>
    <p>
        <img src="../../images/blog/depth-scatter/image16.png"></p>
    <p>If you mouse around a bit, you'll notice that the majority of our values are
crunched within the 0.99..1.0 range - this is because all of these values are relative to the Near and Far
parameters of the Camera COMP - which is 0.1 -&gt; 1000 by default. &nbsp;</p>

    <p>If our objects are only 1 unit deep from the camera, most of that 32-bit float
precision is spent on the other 999 units, resulting in the values we see here. Usually that's fine,
but it's something you can come back to tweak later if you see 'stepping' or other
artifacts in the particle sim.</p>

    <p>Another point to raise here is the Texture Format of the Depth TOP. If you
middle-mouse (or Alt-right click) on the Depth TOP, you'll see this :</p>
    <p>
        <img src="../../images/blog/depth-scatter/image25.png"></p>
    <p>Notice the section marked 'Format' - and compare it to what comes up on
your normal TOPs (which will probably be 8-bit fixed (RGBA)). This means that on the GPU, the texture
backing up this Depth TOP is using a 1-channel 32-bit float, whereas normal tops use a 4-channel (for R,G,B
and Alpha), 8-bit fixed representation. </p>

    <p>This format is used for extra accuracy in the depth map (or depth buffer), so
it's less likely (but not guaranteed) to see z-fighting when two objects are overlapping and similar
in distance from the camera. </p>

    <p>This 32-bit float texture format also allows negative numbers to be stored in the
texture, which will be very important later on.</p>
</section>

<section>

    <h3>Step 4 - Creating the GPU Particle System </h3>

    <p>So now we have a simple 3D scene, and a texture that represents the depth of the
scene relative to the viewer's position.</p>

    <p>What we want to do next is very similar to ray tracing, where we fire an imaginary
ray from the camera's position into the scene, wait for it to hit something, then spawn a particle at
that position.</p>

    <p>The steps are :</p>
    <ul>
        <li>Generate a random position in screen-space (which we'll
call UV, to make it distinct from XY in world space)</li>
        <li>Sample the depth map at this UV position, get the depth value
(which will be between 0 and 1)</li>
        <li>Grab the camera's inverse projection matrix. </li>
    </ul>
    <ul >
        <li >
                                    There's a short explainer on what that is <a
href="https://www.google.com/url?q=https://www.youtube.com/watch?v%3DEqNcqBdrNyI%26ab_channel%3Dpikuma&amp;sa=D&amp;source=editors&amp;ust=1730310899258306&amp;usg=AOvVaw3hwV15uDsY55CsdoDCzW38">here</a>
                                        &nbsp;-
in very simple terms, it's a series of values that describe the properties of
the camera, i.e. its field of view, its near &amp; far planes etc.</li>
    </ul>
    <ul >
        <li>
                                            THE MAGIC BIT : Use this matrix and a bit of maths to convert the values
above into a world space position&nbsp;in 3D.
</li>
        <li>Spawn a particle in a new 3D scene at this location</li>
        <li>Do this many, many times</li>
        <li>Render the new scene.</li>
    </ul>

    <p>
                                            So in diagrams, first we sample a point in screen space, get the depth value:</p>
    <p>
        <img src="../../images/blog/depth-scatter/image2.png"></p>
    <p>This corresponds to a point on the sphere, seen here from a different angle :
</p>
    <p>
        <img src="../../images/blog/depth-scatter/image27.png"></p>

    <p>Now comes the magic / hard bit, depending on your comfort with matrix math (which for
the record, mine is not great). We multiply this screen-space position and depth by the camera's
inverse projection matrix, which gives us a position in 3D space, that we can use to drive a particle
system.</p>

    <p>The next step is to do this for many points per frame, each sampling a different part
of the depth map, so our particles build up &nbsp;a representation of the original 3D scene, like this
:</p>
    <p>
        <img src="../../images/blog/depth-scatter/image20.png"></p>

    <p>So how do we implement this in TouchDesigner?</p>

    <p>First, we create a Noise TOP, (set to Random (GPU), the Pixel Format set to 8-bit
fixed RGBA, Output to Noise, and the input coming from the Depth TOP to match the resolution), and the Depth
TOP itself.</p>

    <p>This Noise is very important, it's going to provide the random per-frame points
for us to sample the depth texture from. It gives us a big list of values in the range (0..1, 0..1, 0..1)
for the red, green and blue channels, which we then use in the compute shader as UV coordinates on the depth
map.</p>

    <p>
        <aside>
            <span >Using 'pictures' as 'data' in this way was one of the big
gotcha moments for me in TouchDesigner, and it's the area that the new POP operator family I think is
trying to address - when you have a texture that represents positions, things like contrast, brightness etc
(via the Level TOP) can do interesting things in 3D space to those positions, but they're not
necessarily easy to visualise or control exactly what's going on, because they're designed to
work with perceptual differences in pictures. It's super fun to play around in this space, and abuse
TOPs in affecting 3D point clouds (what does an Edge Detect do in 3D space, for example?), but I'm
excited to play with the new POPs for more intentional stuff.</p>
        </aside>

        <p>Then we're going to create a Compute Shader to do the conversion of depth map +
camera matrix into world-space positions, but on the GPU. We can do this with a GLSL Multi TOP :</p>

        <p>
            <img src="../../images/blog/depth-scatter/image10.png"></p>

        <p>And plug the Noise TOP and Depth TOP into the multi-input connector, in that order
(important!)</p>

        <p>
            <img src="../../images/blog/depth-scatter/image13.png"></p>

        <p>When you put down a GLSL Multi TOP, by default it's set to use a vertex/pixel
shader, which is what you'd traditionally use for a full-screen post-processing effect. </p>

        <p>
                                                                        We're going to set the Mode to 'Compute
Shader', because they're more flexible, for example letting us write to
more than one output at a time (which okay, you can do in fragment shaders, but it's tricky).
</p>

        <p>
                                                                            Then we set the property called 'Dispatch
Size', in which I've added an expression for the input width &amp; height, divided
by 8. This is another area where compute shaders differ from vertex/fragment shaders, in that you can
directly specify the 'batch size' in which they run (as opposed to being limited to iterating
over vertices and fragments). Optimising this is something that specialised graphics programmers will be
able to tell you more about than me (see <a
href="https://www.google.com/url?q=https://gpuopen.com/learn/optimizing-gpu-occupancy-resource-usage-large-thread-groups/&amp;sa=D&amp;source=editors&amp;ust=1730310899262171&amp;usg=AOvVaw1lhkisafMwSh9SgQNtWEEe">here</a>
                                                                                    ),
but my general understanding is that:</p>

        <ul >
            <li >If you're running a compute shader over a texture (or other buffer
that contains data), your Dispatch Size needs to<br/>
                <span style="text-align:center">
                    = the dimensions of input
buffer / thread size (defined in the shader code itself)</span></li>
        </ul>

        <p>Here we have a Dispatch Size of 160 x 90, and in the compute shader (which
we'll see in a second), a layout of 8 x 8. </p>

        <p>These values have worked fine for me, but if you want to fiddle, you can increase the
size in the shader and change the corresponding number in the Dispatch Size expression. If these mismatch,
you'll either be wasting dispatch cycles (because the shader will be running over parts of the texture
that are out of bounds, and be discarded), or miss processing parts of the input image (because there
won't be enough thread groups dispatched to cover the whole thing).</p>

        <p>
                                                                                            Next we need to pass our camera projection matrix to the compute shader. In the Matrices&nbsp;tab of
the
GLSL Multi TOP, we create a Matrix uniform
called invCamProjection :</p>
        <p>
            <img src="../../images/blog/depth-scatter/image26.png"></p>
        <p>The expression for the value here is :</p>
        <p>
                                                                                                        op(&#39;camSrc&#39;).projectionInverse(op(&#39;depth1&#39;).width,op(&#39;depth1&#39;).height)
</p>

        <p>
                                                                                                            The projectionInverse function here takes in an
aspect ratio, which we give it by specifying the width and height of the Depth TOP. This is because the
camera doesn't specify an aspect ratio itself (that's determined by the Render TOP that uses
it), so in order to create a matrix we need to specify one.</p>

        <p>Now we're ready to create our Compute Shader. Click the first pink arrow
underneath the GLSL Multi TOP to open up the editor, and put in the following :</p>
        <p>
            <br>uniform mat4 invCamProjection;</p>
        <p>layout (local_size_x = 8, local_size_y = 8) in;</p>
        <p>void main()</p>
        <p>{</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ivec2 uv =
ivec2(gl_GlobalInvocationID.xy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
        <p ></p>
        <p>&nbsp; &nbsp; vec2 depthUV = texelFetch(sTD2DInputs[0], uv, 0).xy;</p>
        <p>&nbsp; &nbsp; </p>
        <p>&nbsp; &nbsp; float depth = texture(sTD2DInputs[1], depthUV.xy).r;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 screenspacePos = vec4(-1.0f +
(depthUV.x * 2.0f), -1.0f + (depthUV.y * 2.0f), depth, 1);</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 hpositionWS = invCamProjection *
screenspacePos;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hpositionWS.xyz = hpositionWS.xyz /
hpositionWS.w;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3 posWorld =
hpositionWS.xyz;</p>
        <p ></p>
        <p ></p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageStore(mTDComputeOutputs[0],
ivec2(uv), vec4(posWorld,
1.0f));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
        <p ></p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
        <p>}</p>

        <p>It should look like this in the DAT editor :</p>

        <p>
            <img src="../../images/blog/depth-scatter/image6.png"></p>

        <p>Let's step through this and see what's happening.</p>

        <ul >
            <li>
                                                                                                                            First uniform mat4 invCamProjection&nbsp;is importing our matrix from
the
uniform we defined a second ago, grabbing it from the
Camera COMP.</li>
            <li>
                                                                                                                                    Then layout (local_size_x = 8, local_size_y = 8)
in;&nbsp;specifies the thread group size, see above discussion on Dispatch
Size.</li>
            <li>
                                                                                                                                        We get a texel-based UV ivec2 that we're going to call UV (even though
it's not normalised) ivec2 uv =
ivec2(gl_GlobalInvocationID.xy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`</li>
            <li>
                                                                                                                                            We sample the first input (which is our Noise TOP) to get a random XY
coordinate in (0..1, 0..1). Here we use texelFetch&nbsp;because our UV coordinate is in the space
(0..width, 0..height).</li>
            <li>
                                                                                                                                                    Then we sample the input depth map using our depthUV&nbsp;value
-
using texture&nbsp;because depthUV&nbsp; is
normalised (0..1). From this we get a float depth, which
is normalised (0..1), where 0 is the near plane and 1 is the far plane of the
camera.
</li>
            <li>
                                                                                                                                                                            The camera matrix works in a 'screen space' coordinate system
that extends from (-1,1, -1,1), so we convert our depthUV&nbsp;coordinates into this
screenspacePos&nbsp;space on line 14, and (important!) add depth&nbsp;as
the
z&nbsp;component, and a 1
    as the w&nbsp;component because we're working with 4x4
        matrices, and our next step needs a vec4.</li>
            <li>
                                                                                                                                                                                                                Now comes the matrix math - we multiply invCamProjection&nbsp;by
screenspacePos&nbsp;</li>
        </ul>
        <ul >
            <li >
                                                                                                                                                                                                                                &hellip;and this should give us our world-space position, right? NO.
Because matrix math, we need to divide the xyz&nbsp;component by
the w&nbsp;component of the resulting vector, which
happens on the next line. Maybe someone can explain to be why one day.</li>
        </ul>
        <ul >
            <li>
                                                                                                                                                                                                                                        We then imageStore&nbsp;this
value into our output texture.</li>
        </ul>

        <p>If this all works, and the GLSL Multi TOP doesn't report any errors, you should
see something like this in the viewer :</p>

        <p>
            <img src="../../images/blog/depth-scatter/image18.png"></p>
        <p>And if you enable Normalised Split in the viewer as above, you can see the bounds of
the positions we've extracted from the depth map &amp; camera matrix :</p>

        <p>
            <img src="../../images/blog/depth-scatter/image9.png"></p>

        <p>Each point in this output texture will represent an output particle, so if our input
image is 1280x720, we'll have 921,600 particles - which is quite a lot, but no big deal for a modern
GPU to handle. You can specify a larger or smaller amount by manually changing the resolution of your input
Noise TOP.</p>

        <p>Our B channel represents Z, and we see the minimum value as -1000, which is the
'far' plane of the camera. And we also notice some large values for the extents of R &amp; G, so
what's happening here?</p>

        <p>Well a lot of our particles will hit the 'background' of the Depth map,
meaning there weren't any 3D objects there, so they return a depth value of 1, and are scattered over
an imaginary surface at -1000 away from the camera. We can either discard these particles (see later when we
talk about particle lifetimes) or specify a closer Far plane in the camera we use for rendering our
particles, so they get clipped off.</p>

        <p>Now let's use these positions to render some particles!</p>
    </section>
    <section>

        <h3>Step 5 - Rendering the particles</h3>
        <p ></p>
        <p>One of TouchDesigner's best party tricks is Instancing, where you can input a
simple bit of geometry, but duplicate it many, many times on the GPU very performantly, driving it with a
mixture of TOPs, CHOPs or DATs - whatever you want, just as long as the dimensions match up. This lets you
do lots of creative things with point clouds, if you scroll Instagram for #touchdesigner you'll see a
lot of this technique being used in live VJ sets and installations. </p>

        <p>So for our particles, we're going to create a simple Box SOP, and wire this
into a Geometry COMP, so we have something to render :</p>
        <p>
            <img src="../../images/blog/depth-scatter/image12.png"></p>

        <p>
                                                                                                                                                                                                                                                    Then we go to the Instancing tab of the geo1&nbsp;COMP, and
turn on Instancing, and drag the GLSL Multi TOP into the Translate OP&nbsp;field. Then we assign
r, g
and b to the Translate X, Y and Z parameters respectively
(there's a drop-down under the arrow on the right). </p>

        <p>The next that that happens is that TouchDesigner might get super slow, this is
because our Box TOP is way too large and causing lots of overdraw in the Geo viewer. </p>

        <p>So we go back to our Box SOP, and turn down the Uniform Scale to something like 0.01,
until we see something like this in the Geo viewer - you might need to hunt around a bit using the in-built
camera to find your points.</p>
        <p>
            <img src="../../images/blog/depth-scatter/image15.png"></p>

        <p>You might also see this collection of points splatted against a 'back
wall', with a shadow of missing points in the outline of your objects - that's the points that
missed any objects, which we can deal with later.</p>

        <p>
                                                                                                                                                                                                                                                                    Next we can create a new Render TOP, but specify only geo1&nbsp;in the Geometry property,
so
it only renders the particles. Specify the original camera in the corresponding
Render TOP property, and it should look something like this :</p>

        <p>
            <img src="../../images/blog/depth-scatter/image19.png"></p>

        <p>And we've made our first depth-scattered particle system!</p>

        <p>Things to check if it doesn't :</p>
        <ul >
            <li>Uniform Scale of the Box SOP, if you make this 1, you should see
some particles around the place</li>
            <li>The Normalised Split view of the GLSL Multi TOP, it should look
like noise (i.e. different values scattered across the place), and have a max/min around half of your
Camera's Far plane.</li>
        </ul>

        <p>But this isn't particularly exciting by itself, we're going to take this
a bit further.</p>

        <p>Step 6 - Particle lifetime, colour &amp; motion</p>
        <p ></p>
        <p>Currently we're creating new 'particles' every frame, and then
overwriting these all on the next frame.</p>

        <p>We're also sampling the same particle position on the depth map, because our
input Noise TOP is not changing.</p>

        <p>Let's make our Noise move, by plugging the current frame number into the random
Seed parameter:</p>

        <p>
            <img src="../../images/blog/depth-scatter/image28.png"></p>

        <p>What we want to do is:</p>
        <ul >
            <li>Maintain a list of particle 'lifetimes', which reduce
over time</li>
            <li>When a particle's lifetime reaches 0, we sample a new point
on the depth map, and reset its lifespan.</li>
        </ul>

        <p>We do this by having our Compute Shader write to a second texture, to store the
lifetime of that particle, which gets read back in on the next frame.</p>

        <p>Something nice about Compute Shaders is that we can both read and write to our output
texture buffers, and provided we're always reading/writing to the same part of the texture for each
particle that we process, we won't get into trouble. Of course, if we started reading &amp; writing to
another part of the texture (i.e. another particle), we don't know whether this frame's
calculation has completed on that part, so we could get unexpected results.</p>

        <p>So let's create a second output for our Compute Shader to write to, in the GLSL
Multi TOP :</p>
        <p>
            <img src="../../images/blog/depth-scatter/image7.png"></p>
        <p>What you'll notice is there's no increase in output connectors on the
GLSL Multi TOP, we need to use a Render Select TOP to extract this buffer :</p>
        <p>
            <img src="../../images/blog/depth-scatter/image22.png"></p>

        <p>
                                                                                                                                                                                                                                                                                                    You can also see that I've attached a Null TOP to the output of the GLSL and called it
positions.</p>

        <p>Assign the GLSL top to the TOP parameter of the Render Select TOP, and set the index
to 1. Initially, it'll be blank because we're not writing to it yet.</p>

        <p>Let's modify our Compute Shader to see how easy it is to write to multiple
outputs:</p>
        <p>
            <img src="../../images/blog/depth-scatter/image11.png"></p>

        <p>Here we've added a line 22, which writes (1,0,1,1) to the output at index 1,
which gives us a nice pink colour in the Render Select TOP :</p>
        <p>
            <img src="../../images/blog/depth-scatter/image23.png"></p>

        <p>Now we need to modify our shader to do the following<br>- read the current lifetime
value of our particle from the lifetime buffer</p>
        <p>- if it's greater than 0, decrease it by some small amount, write it back to
the buffer</p>
        <p>- if it's less than or equal to 0, re-sample the depth buffer, calculate a new
world-space position for the particle, and reset the lifetime.</p>

        <p>So our compute shader will change to this:</p>

        <p>uniform mat4 invCamProjection;</p>
        <p>layout (local_size_x = 8, local_size_y = 8) in;</p>
        <p>void main()</p>
        <p>{</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ivec2 uv =
ivec2(gl_GlobalInvocationID.xy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 lifetime =
imageLoad(mTDComputeOutputs[1], uv);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (lifetime.x &gt; 0){</p>
        <p>
                                                                                                                                                                                                                                                                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lifetime.x
-= 0.1f;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</p>
        <p>
                                                                                                                                                                                                                                                                                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lifetime.x
= 1.0f;</p>
        <p ></p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp;vec2 depthUV = texelFetch(sTD2DInputs[0], uv,
0).xy;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp;float depth = texture(sTD2DInputs[1],
depthUV.xy).r;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
        <p>
                                                                                                                                                                                                                                                                                                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4
screenspacePos = vec4(-1.0f + (depthUV.x * 2.0f), -1.0f + (depthUV.y * 2.0f), depth, 1);</p>
        <p>
                                                                                                                                                                                                                                                                                                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
        <p>
                                                                                                                                                                                                                                                                                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4
hpositionWS = invCamProjection * screenspacePos;</p>
        <p>
                                                                                                                                                                                                                                                                                                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hpositionWS.xyz
= hpositionWS.xyz /
hpositionWS.w;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
        <p>
                                                                                                                                                                                                                                                                                                                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3
posWorld = hpositionWS.xyz;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
        <p>
                                                                                                                                                                                                                                                                                                                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageStore(mTDComputeOutputs[0],
ivec2(uv), vec4(posWorld,
1.0f));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
        <p ></p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageStore(mTDComputeOutputs[1],
ivec2(uv), lifetime);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
        <p>}</p>

        <p>
                                                                                                                                                                                                                                                                                                                                                Now if we look at our outputs, we should see the lifetime&nbsp;TOP flashing from pink to blue,
and
the positions&nbsp;TOP changing pattern whenever it changes to pink.
</p>

        <p>This is nice, but we don't want our particles all re-birthing at the same time,
so we need to add some variation.</p>

        <p>
            <span >There's other ways of doing this, for sure, such as seeding the lifetime
texture with a noise pattern on reset.</p>
            <p >
                <span ></p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                        We can do this by using the (unused, so far) part of the input noise, and using it to affect
both the age rate and the life expectancy. We need to shuffle our compute shader around a bit, so we sample
the whole noise component before the if&nbsp;statement
:</p>

                <p>uniform mat4 invCamProjection;</p>
                <p>layout (local_size_x = 8, local_size_y = 8) in;</p>
                <p>void main()</p>
                <p>{</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ivec2 uv =
ivec2(gl_GlobalInvocationID.xy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 noise =
texelFetch(sTD2DInputs[0], uv, 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// sample noise
input</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 lifetime =
imageLoad(mTDComputeOutputs[1], uv);</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (lifetime.x &gt; 0){</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lifetime.x
-= 0.1f * noise.b;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lifetime.x
= 1.0f * noise.b;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2
depthUV = noise.xy;</p>
                <p ></p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float
depth = texture(sTD2DInputs[1], depthUV.xy).r;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4
screenspacePos = vec4(-1.0f + (depthUV.x * 2.0f), -1.0f + (depthUV.y * 2.0f), depth, 1);</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4
hpositionWS = invCamProjection * screenspacePos;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hpositionWS.xyz
= hpositionWS.xyz /
hpositionWS.w;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3
posWorld = hpositionWS.xyz;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageStore(mTDComputeOutputs[0],
ivec2(uv), vec4(posWorld,
1.0f));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                <p ></p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageStore(mTDComputeOutputs[1],
ivec2(uv),
lifetime);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>}</p>

                <p>We should now see the positions and lifetimes changing a bit more evenly. In our
final render, we should see particles glittering across the surface a bit. But the effect is pretty subtle,
because our underlying depth map isn't changing.</p>

                <p>Let's add some motion to our source image so we can see the effect of particle
lifetime on this end image.</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                            Let's go back to our srcGeo (the one
holding the sphere, triangle and torus), and make it spin, but putting an expression inside the Rotate Y
parameter :</p>

                <p>
                    <img src="../../images/blog/depth-scatter/image8.png"></p>

                <p>Now we should be able to see a bit of a difference in the final render. It's
still a little uninspiring though, so let's push on with some more particle behaviours &amp;
effects.</p>

                <p>For example, let's sample the colour of the original render - which (depending
on your original material setup) will include shadows.</p>

                <p>Connect the original Render TOP into the GLSL Multi TOP, and check that it's in
position 2 in the list :</p>
                <p>
                    <img src="../../images/blog/depth-scatter/image1.png"></p>

                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                        Now we could create a new output buffer to hold the colour information for the particles, but as
we're only using one channel of our lifetime&nbsp;buffer, we could use the other three to store
colour.
</p>

                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                So let's do that - first by moving the channel we use to store lifetime to the
w&nbsp;channel (or alpha) channel of the output, and then by sampling the
render buffer input, and storing that in the rgb&nbsp;channels.</p>

                <p>New compute shader:</p>

                <p>uniform mat4 invCamProjection;</p>
                <p>layout (local_size_x = 8, local_size_y = 8) in;</p>
                <p>void main()</p>
                <p>{</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ivec2 uv =
ivec2(gl_GlobalInvocationID.xy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 noise =
texelFetch(sTD2DInputs[0], uv, 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// sample noise
input</p>
                <p ></p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 lifetime =
imageLoad(mTDComputeOutputs[1], uv);</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (lifetime.w &gt; 0){</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lifetime.w
-= 0.1f * noise.b;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lifetime.w
= 1.0f * noise.b;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2
depthUV = noise.xy;</p>
                <p ></p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float
depth = texture(sTD2DInputs[1], depthUV.xy).r;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3
colour = texture(sTD2DInputs[2], depthUV.xy).rgb;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lifetime.rgb
= colour;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4
screenspacePos = vec4(-1.0f + (depthUV.x * 2.0f), -1.0f + (depthUV.y * 2.0f), depth, 1);</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4
hpositionWS = invCamProjection * screenspacePos;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hpositionWS.xyz
= hpositionWS.xyz /
hpositionWS.w;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3
posWorld = hpositionWS.xyz;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageStore(mTDComputeOutputs[0],
ivec2(uv), vec4(posWorld,
1.0f));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                <p ></p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageStore(mTDComputeOutputs[1],
ivec2(uv),
lifetime);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p ></p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>}</p>
                <p ></p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    In order to display these colours on our particles, we need to go to the Instance 2 tab on our
particle geo1, and drag into the lifetime TOP, and set the
R, G, B parameters accordingly:</p>
                <p>
                    <img src="../../images/blog/depth-scatter/image3.png"></p>

                <p>What we should then see is our particles in the final Render TOP obtain the same
colour as in the original render. It might help to set the Camera COMP to render with a black background to
see better.</p>

                <p>What we can also do at this stage is use the actual lifetime channel (a, or w) to
control the scale of the particles, so they fade away instead of popping in and out. </p>

                <p>We can tweak the amount we decrease the lifetime by each frame in order to see this
more clearly - and also notice the 'time smearing' effect we get with this change, which is a
key part of this whole system. I like to adjust this depending on the amount of movement in the original
scene, to give something that's either deliberately abstract or really clear, depending on the
moment.</p>

                <p>
                    <img src="../../images/blog/depth-scatter/image24.png"></p>

                <p>One last thing, is adding some movement into the particles themselves, so for example
some gravity. For this we need to read the current position, modify it, and write it back when the lifetime
&gt; 0 in the compute shader, which now looks like this &nbsp;(we've had to shuffle around the
read/write commands to the position buffer) a bit :</p>

                <p>uniform mat4 invCamProjection;</p>
                <p ></p>
                <p>layout (local_size_x = 8, local_size_y = 8) in;</p>
                <p>void main()</p>
                <p>{</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ivec2 uv =
ivec2(gl_GlobalInvocationID.xy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 noise =
texelFetch(sTD2DInputs[0], uv, 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// sample noise
input</p>
                <p ></p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 lifetime =
imageLoad(mTDComputeOutputs[1], uv);</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4 position =
imageLoad(mTDComputeOutputs[0], uv);</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (lifetime.w &gt; 0){</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lifetime.w
-= 0.01f * noise.b;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.y
-= 0.01f *
sin(noise.b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lifetime.w
= 1.0f * noise.b;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec2
depthUV = noise.xy;</p>
                <p ></p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float
depth = texture(sTD2DInputs[1], depthUV.xy).r;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec3
colour = texture(sTD2DInputs[2], depthUV.xy).rgb;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lifetime.rgb
= colour;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4
screenspacePos = vec4(-1.0f + (depthUV.x * 2.0f), -1.0f + (depthUV.y * 2.0f), depth, 1);</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec4
hpositionWS = invCamProjection * screenspacePos;</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hpositionWS.xyz
= hpositionWS.xyz /
hpositionWS.w;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position
= vec4(hpositionWS.xyz,
1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageStore(mTDComputeOutputs[0],
ivec2(uv),
position);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageStore(mTDComputeOutputs[1],
ivec2(uv),
lifetime);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
                <p>}</p>

                <p>And we should have something like this :</p>

                <p>
                    <img src="../../images/blog/depth-scatter/image5.png"></p>

                <p>Where our particles are falling a bit like sand.</p>

                <p>Step X - Next Steps?</p>

                <p>We're now into the region of programming general GPU particle simulations in a
compute shader, which is a well-established field of work in itself, with lots of resources. - a quick
Google for 'TouchDesigner GPU Particles' will give you a whole bunch of things to try out, so
our tutorial is going to pause here for now.</p>

                <p>Things to look into:</p>
                <ul >
                    <li>Per-instance textures (as used in the Harmonic Dream Sequence
video above)</li>
                    <li>Using a different camera to render the final particles than the
one that creates the depth map</li>
                </ul>
                <ul >
                    <li>Adding position noise over lifetime</li>
                    <li>Varying the size of particles, e.g. based on colour, or noise
lookup</li>
                    <li>Having a small random subset of particles 'glitter'
or shine</li>
                    <li>Having some percentage of particles randomly scattered in space,
as a dust effect, which helps give a sense of parallax when moving the camera a lot.</li>
                    <li>Using inputs like the Kinect Camera (which will output a point
cloud by itself), or grayscale patterns with a moving camera to create interesting 'swept'
shapes through 3D space.</li>
                </ul>

                <p>Many of these effects I've implemented in my own systems, inspired a great deal
by Keijiro's work in the Unity Visual Effect Graph (particularly the glitter effect).</p>

                <p>There's also going to be alternative (and maybe even better!) methods to
achieve all of the above, but this approach has taught me a whole lot about compute shaders, and let me
control the particle behaviour in a very precise way, and all in realtime!</p>

                <p>The next thing I'm going to look at (and maybe write an article on) is
importing these position buffers into a program like Houdini for rendering the particles in a more high-end
manner. Why? Because simulation in Houdini can be a bit slow, and unless you're using OpenCL nodes,
not necessarily GPU-accelerated. I've already done some tests with importing the position buffers into
Houdini as an image sequence, so watch this space.</p>
        </main>
        <footer>
            <p>Owen Hindley, 2024</p>

        </footer>

    </div>
</body>
</html>